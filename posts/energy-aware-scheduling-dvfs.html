<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>With Great Power Comes Great Responsibility ‚Äî Energy Aware Scheduling and DVFS for modern SoCs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <meta name="description" content="A deep dive into power management in modern SoCs, covering Dynamic Voltage and Frequency Scaling (DVFS), Static vs Dynamic power, and Energy Aware Scheduling (EAS).">
  <meta name="keywords" content="GPU, SoC, DVFS, EAS, Energy Aware Scheduling, Power Management, Thermal Throttling, ARM, Qualcomm, Mobile Hardware">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <style>
    /* Using your existing CSS styles from the previous blogs */
    .layout { position: relative; }
    @media (min-width: 1100px) {
      main { max-width: 980px; padding-right: 280px; }
      .toc { display: block; position: fixed; right: 24px; top: 110px; width: 240px; max-height: calc(100vh - 140px); overflow: auto; border: 1px solid #e4e4e4; background: rgba(255,255,255,0.92); backdrop-filter: blur(6px); border-radius: 10px; padding: 12px; box-shadow: 0 8px 20px rgba(0,0,0,0.06); }
    }
    .toc { display: none; }
    .toc-title { font-family: ui-monospace, monospace; font-size: 0.85rem; font-weight: 700; color: #333; margin-bottom: 8px; }
    .toc a { display: block; text-decoration: none; color: #222; font-size: 0.88rem; padding: 6px 8px; border-radius: 8px; line-height: 1.35; }
    .toc a:hover { background: #f3f3f3; }
    .toc a.active { background: #e7f0ff; color: #0046a8; font-weight: 600; }
    
    body { font-family: system-ui, sans-serif; line-height: 1.6; margin: 0; background: #fafafa; color: #222; }
    main { max-width: 780px; margin: 0 auto; padding: 2.5rem 1.25rem 4rem; background: #ffffff; }
    h1, h2, h3 { line-height: 1.3; font-weight: 700; color: #111; }
    h2 { font-size: 1.6rem; margin-top: 2.2rem; border-bottom: 1px solid #eee; padding-bottom: 0.5rem; }
    img { max-width: 100%; height: auto; display: block; margin: 1.4rem auto; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
    figure { margin: 1.6rem 0; text-align: center; }
    figcaption { font-size: 0.9rem; color: #666; margin-top: 0.4rem; }
    .lead { font-size: 1.1rem; font-style: italic; color: #444; }
    .signature { margin-top: 2rem; font-weight: 600; }
    .back-home { display: inline-block; margin-bottom: 20px; color: #0066cc; text-decoration: none; font-size: 0.9rem; }
    .tags span { display: inline-block; background: #e7f0ff; color: #0046a8; padding: 4px 10px; margin: 4px 6px 0 0; border-radius: 6px; font-size: 0.85rem; }

    /* Dark Mode */
    @media (prefers-color-scheme: dark) {
      body { background: #050608; color: #f4f4f4; }
      main { background: #111319; }
      h1, h2, h3 { color: #ffffff; }
      .toc { border-color: #333; background: rgba(17,19,25,0.85); }
      .toc-title, .toc a { color: #f4f4f4; }
      .toc a:hover { background: #181b23; }
      .toc a.active { background: #22304a; color: #cfe3ff; }
      .lead { color: #ccc; }
    }

    /* Typewriter Style Header */
    .blog-main-title { font-size: 2.2rem; font-weight: 800; margin: 0; font-family: "Courier New", monospace; }
    .blog-sub-title { font-size: 1.2rem; font-weight: 400; margin: 5px 0; opacity: 0.8; }
    .watermark { position: fixed; left: 12px; bottom: 10px; font-size: 12px; color: rgba(15, 23, 42, 0.5); }
  </style>
</head>

<body>
  <div class="layout">
    <aside class="toc" aria-label="Table of contents">
      <div class="toc-title">ON THIS PAGE</div>
      <nav id="toc-list"></nav>
    </aside>

    <main>
      <article>
        <header>
          <a href="../index.html" class="back-home">‚Üê Back to Home</a>
          <div class="blog-title-block">
            <h1 class="typewriter-line blog-main-title" data-text="With Great Power Comes Great Responsibility"></h1>
            <h2 class="typewriter-line blog-sub-title" data-text="Energy Aware Scheduling and DVFS in modern SoCs"></h2>
          </div>
          
          <div style="margin: 15px 0; font-size: 0.9rem; color: #666;">
            <span>üë§ Ankit Singh (Senior Engineer - GPU Research)</span> | 
            <span>üìÖ Published: 27 Feb 2026</span>
          </div>

          <div class="tags">
            <span>#PowerManagement</span><span>#DVFS</span><span>#EAS</span><span>#SoC</span><span>#MobileArchitecture</span>
          </div>
        </header>

        <p class="lead">
          I recently watched the trailer for <em>Masters of the Universe</em>, and that iconic line, "I have the Power!" really stuck with me. It resonated so much that I decided it was time to finally write my next article about power. (Joking, but you really should check out that trailer! :D)
        </p>

        <figure>
          <img src="../assets/img/blog3/1.png" alt="I have the power">
          <figcaption>The ultimate goal of every SoC designer: having the power, but managing it wisely.</figcaption>
        </figure>

        <p>I've been meaning to write about dynamic power consumption in mobile systems for a while now‚Äîspecifically, how modern devices manage it through software. Our drivers are already quite diligent, constantly calculating which frequency to set based on the CPU or GPU workload. However, these estimates are tricky. We always want peak performance, but we can't let the device turn into a pocket-sized furnace.</p>

        <h2 id="tldr">TLDR</h2>
        <figure>
          <img src="../assets/img/blog3/2.png" alt="Power TLDR">
          <figcaption>A quick summary of the power-performance balancing act.</figcaption>
        </figure>

        <h2 id="introduction">Introduction</h2>
        <p>Let's take a breath and start step-by-step. First, we need to understand <strong>Frequency</strong> and how it causes thermal power to increase.</p>
        <p>Computers run on a <strong>clock signal</strong>. With each tick, they execute instructions. <br>
           <strong>Frequency = how many times per second the clock ticks.</strong></p>
        
        <ul>
          <li><strong>More ticks</strong> ‚Üí more instructions processed ‚Üí faster performance (The high achiever's dream).</li>
          <li><strong>More frequency</strong> ‚Üí More switching of tiny transistors per second.</li>
          <li><strong>More switching</strong> ‚Üí More power used, generated, and dissipated (The overheating reality).</li>
        </ul>
        
        <p>Hope its explains in brief why every mobile chip doesn't just run its maximum frequency but at an <strong>optimum frequency</strong>  that balances performance and power. Overheating issues not only affects the performance but may damage the chips as well. It becomes highest priority of the system to control power first then care for performance. Diagram below explains how when frequency increases it may reach a critical point then voltage and frequency have to adjusted sharply to mana temperature. (I don't swear by numbers plotted here , this just to explain the scenario) </p>
        <figure>
          <img src="../assets/img/blog3/3.png" alt="Frequency vs Temperature">
          <figcaption>Conceptual diagram: As frequency increases, temperature rises exponentially, forcing a sharp adjustment in voltage.</figcaption>
        </figure>

        <h2 id="static-vs-dynamic-power">Static vs Dynamic Power</h2>
        
        <p>Hopefully I have hooked enough to care about power. In the context of System-on-Chip (SoC) design, power consumption is generally divided into two main categories: <strong>Dynamic Power</strong> (power consumed while the circuit is active and switching) and <strong>Static Power</strong> (power consumed even when the circuit is idle).</p>
        
        <p>As process nodes have shrunk (e.g., from 90nm down to 5nm), the balance between these two has shifted significantly. In older technologies, dynamic power was the dominant factor; in modern "FinFET" and sub-10nm nodes, static power (leakage) can account for 50% or more of the total power budget.</p>
        
        <h3 id="dynamic-power">1. Dynamic Power (P<sub>dyn</sub>)</h3>
        
        <p>Dynamic power is the energy consumed by the transition of logic states (0‚Üí1 and 1‚Üí0). It is composed of two sub-components:</p>
        
        <ul>
          <li><strong>Capacitive Switching Power:</strong> This is the energy required to charge and discharge the parasitic capacitance of the logic gates and the interconnect wires.</li>
          <li><strong>Internal Power (Short-circuit):</strong> During a transition, there is a momentary "crowbar" effect where both the PMOS and NMOS transistors are partially ON, creating a direct path from VDD to Ground.</li>
        </ul>
        
        <p><strong>The Formula:</strong></p>
        \[P_{dyn} \approx \alpha \cdot C \cdot V^2 \cdot f\]
        
        <ul>
          <li><strong>&alpha;:</strong> Activity factor (how often the signal flips).</li>
          <li><strong>C:</strong> Capacitance of the circuit.</li>
          <li><strong>V:</strong> Supply voltage.</li>
          <li><strong>f:</strong> Clock frequency.</li>
        </ul>
        
        <blockquote>
          <p><strong>Key Takeaway:</strong> Because Voltage (V) is squared, reducing the supply voltage is the most effective way to cut dynamic power.</p>
        </blockquote>
        
        <h3 id="static-power">2. Static Power (P<sub>static</sub>)</h3>
        
        <p>Static power, often called <strong>Leakage Power</strong>, is the energy consumed while the transistors are "off." Even when a transistor is theoretically closed, small amounts of current trickle through the silicon.</p>
        
        <p>The primary contributors to static power are:</p>
        
        <ul>
          <li><strong>Sub-threshold Leakage:</strong> Current that flows between the source and drain even when the gate voltage is below the threshold (Vgs &lt; Vth).</li>
          <li><strong>Gate Leakage:</strong> Current "tunnelling" through the extremely thin gate oxide layer.</li>
          <li><strong>Reverse-bias Junction Leakage:</strong> Current leaking through the P-N junctions of the transistor.</li>
        </ul>
        
        <p><strong>The Formula (Simplified):</strong></p>
        \[P_{static} \approx I_{leakage} \cdot VDD\]
        
        <blockquote>
          <p><strong>Key Takeaway:</strong> Static power is highly sensitive to temperature. As a chip gets hotter, leakage current increases exponentially, which can lead to "thermal runaway."</p>
        </blockquote>
        
        <h3 id="comparison-at-a-glance">Comparison at a Glance</h3>
        
        <figure>
          <img src="../assets/img/blog3/4.png" alt="Dynamic vs Static Power Comparison">
          <figcaption>A high-level comparison of Dynamic and Static power characteristics.</figcaption>
        </figure>
        
        <h3 id="how-they-interact-in-an-soc">How they interact in an SoC</h3>
        
        <p>In a real-world scenario like a smartphone:</p>
        
        <ol>
          <li><strong>While gaming:</strong> Your SoC uses high <strong>Dynamic Power</strong> because the GPU and CPU are switching at gigahertz speeds.</li>
          <li><strong>While in your pocket:</strong> Your SoC's <strong>Static Power</strong> is the primary culprit for draining the battery, as thousands of "off" transistors are still leaking current.</li>
        </ol>
        
        <p>To combat this, designers use <strong>Power Gating</strong>, where they physically shut off the power supply to idle blocks (like a light switch), effectively reducing leakage current to near zero for those specific areas.</p>

        <h2 id="strategies-to-manage-power">Strategies to Manage Power (Dynamic Power)</h2>
        
        <p>Since I only worked on dynamic power, I will only tell you about that. Power Gating methods are used to control Static power though. But as I said I want to deal with the strategies where it can be controlled in software; usually, static power strategies often require hardware-specialised supports. Let's dive into Dynamic power strategies.</p>
        
        <p>Dynamic power is governed by the equation \(P_{dyn} \approx \alpha \cdot C \cdot V^2 \cdot f\). Most strategies focus on reducing one of these variables: frequency, voltage, or both.</p>
        
        <ul>
          <li><strong>Clock Gating:</strong> The most common technique. It shuts off the clock signal to logic blocks that are not performing a function. This reduces the activity factor (\(\alpha\)) to zero for those registers.</li>
          <li><strong>Voltage and Frequency Scaling (DVFS):</strong> This adjusts \(V\) and \(f\) based on workload. Because \(V\) is squared, dropping the voltage by <strong>20%</strong> can reduce dynamic power by nearly <strong>40%</strong>. Scaling can occur at different levels:
            <ul>
              <li><strong>Static Voltage Scaling (SVS):</strong> Different blocks of the SoC are given different, fixed voltages.</li>
              <li><strong>Multi-level Voltage Scaling (MVS):</strong> A block can switch between a few discrete voltage/frequency "performance levels" (e.g., High, Medium, Low).</li>
              <li><strong>Dynamic Voltage and Frequency Scaling (DVFS):</strong> The voltage and frequency are adjusted continuously (or in very fine steps) in response to real-time workload changes.</li>
              <li><strong>Adaptive Voltage Scaling (AVS):</strong> The most advanced form, where a <strong>closed-loop hardware monitor</strong> (like a performance monitor or ring oscillator) tracks process, voltage, and temperature (PVT) variations to find the absolute minimum voltage required for a target frequency.</li>
            </ul>
          </li>
        </ul>
        
        <p>While standard techniques like clock gating offer linear power savings, DVFS targets the <strong>quadratic relationship</strong> between voltage and power (\(P \propto V^2f\)), offering exponential savings.</p>
                
        <h2 id="dvfs">Dynamic Voltage and Frequency Scaling (DVFS)</h2>
        
        <p><strong>Dynamic Voltage and Frequency Scaling (DVFS)</strong> is a sophisticated power management technique used in modern SoC design. It leverages the fact that CMOS power consumption is proportional to the square of the operating voltage (\(V^2\)) and linearly proportional to frequency (\(f\)).</p>
        
        <p>By reducing both simultaneously during periods of low computational demand, you achieve an exponential reduction in power compared to simply slowing down the clock.</p>
        
        <h3 id="physics-of-dvfs">1. The Physics of DVFS</h3>
        
        <p>To understand why DVFS is so effective, we look at the <strong>Dynamic Power Equation</strong>:</p>
        
        \[P_{dynamic} = \alpha \cdot C \cdot V^2 \cdot f\]
        
        <p>If a processor is under-utilized, you could simply reduce the frequency (\(f\)) by half. This reduces power by <strong>50%</strong>. However, because CMOS gate delay decreases as voltage increases, a lower frequency allows you to also lower the supply voltage (\(V\)).</p>
        
        <p>If you reduce <strong>both</strong> \(V\) and \(f\) by half, the power reduction is:</p>
        
        \[P_{new} \propto (0.5V)^2 \cdot (0.5f) = 0.125 \cdot P_{original}\]
        
        <p>That is an <strong>87.5% reduction</strong> in power.</p>
        
        <figure>
          <img src="../assets/img/blog3/5.png" alt="Physics of DVFS power reduction">
          <figcaption>The combined effect of scaling voltage and frequency.</figcaption>
        </figure>
        
        <h3 id="design-challenges">2. Design Challenges</h3>
        
        <p>While DVFS is powerful, it introduces significant complexity for the design engineer:</p>
        
        <ul>
          <li><strong>Timing Sign-off:</strong> You must verify timing at <strong>multiple corners</strong> to ensure different voltages can support specific frequencies (e.g., 0.8V @ 400MHz, 1.2V @ 1.2GHz). These validated pairs are known as <strong>Operating Performance Points (OPP)</strong>.</li>
          <li><strong>Temperature Inversion:</strong> In modern FinFET nodes, transistors can actually slow down when it gets colder at very low voltages. This makes "Worst Case" timing analysis much harder.</li>
          <li><strong>Software Overhead:</strong> The OS must be "smart" enough to predict workload. If it switches states too often, the energy spent switching the regulators might exceed the energy saved!</li>
        </ul>
        
        <h3 id="dvfs-software-stack">3. Software stack for DVFS</h3>
        
        <p>The software stack for DVFS is typically divided into three layers:</p>
        
        <ul>
          <li><strong>A. The Governor (The Decision Maker):</strong> The high-level policy engine. It monitors CPU utilization (e.g., every 10‚Äì20ms) and decides whether to scale. Common Linux governors include <strong>Performance</strong>, <strong>Powersave</strong>, <strong>Ondemand</strong>, and <strong>Schedutil</strong> (the modern standard using direct scheduler data).</li>
          <li><strong>B. The Framework (The Intermediate):</strong> Acts as a translator (e.g., <code>cpufreq</code> in Linux). It maintains the <strong>OPP Table</strong> and ensures the software never requests an "illegal" frequency.</li>
          <li><strong>C. The Driver (The Executor):</strong> Communicates with physical hardware (PMU/PLL) and manages the "Step-Up" and "Step-Down" sequences to maintain chip stability.</li>
        </ul>
        
        <h2 id="race-to-sleep-vs-dvfs">Managing "Race to Sleep" vs. DVFS</h2>
        
        <p>Software developers face a classic dilemma when optimizing for power:</p>
        
        <ol>
          <li><strong>Race to Sleep:</strong> Run the CPU at maximum speed to finish the task as fast as possible, then shut the core off entirely (Power Gating).</li>
          <li><strong>DVFS (Slower & Steadier):</strong> Run the CPU at a lower frequency so it finishes "just in time."</li>
        </ol>
        
        <p><strong>Software Strategy:</strong> For purely computational tasks like rendering, "Race to Sleep" is often better to minimize static leakage. For interactive tasks like scrolling a webpage, DVFS is superior because it prevents the "jitter" of constant power cycling.</p>
        
        <h2 id="latency-and-deadlines">Real-Time Deadlines and Latency</h2>
        
        <p>Changing voltage and frequency isn't instantaneous; it has <strong>Transition Latency</strong>. If a high-priority interrupt arrives while the CPU is in a low-power state, it can take 50‚Äì100 microseconds to ramp up the voltage.</p>
        
        <p><strong>Solution:</strong> Advanced software uses <strong>Input Boosters</strong>. When you touch a smartphone screen, the OS immediately boosts the frequency to max <em>before</em> the application even starts processing the touch, ensuring the UI feels fluid.</p>
        
        <h2 id="software-guardbands">Software-Controlled Guardbands</h2>
        
        <p>Modern software can reduce the "extra voltage" margins built in for aging or defects. Through <strong>Adaptive Software Scaling</strong>, the system monitors error rates. If the error rate is zero, the software "undervolts" the chip below the official OPP table to save even more power.</p>
        
        <figure>
          <img src="../assets/img/blog3/6.png" alt="Summary of Software DVFS Strategy">
          <figcaption>Summary of software-driven DVFS strategy and performance layers.</figcaption>
        </figure>

        <h2 id="did-i-want-to-tell-something-more">Did I want to tell something more</h2>
        
        <p>Yeah, I just want to cover briefly how actually devices know if they are getting heated and should control the urge for more and more performance.</p>
        
        <h3 id="thermal-framework-tsens">The Thermal Framework & TSENS</h3>
        
        <p>Modern SoCs are peppered with <strong>TSENS (Thermal Sensors)</strong>‚Äîtiny hardware probes located near "hotspots" like the CPU clusters, GPU, and Modem.</p>
        
        <ol>
          <li><strong>Polling & Thresholds:</strong> The software framework polls these sensors constantly. It has defined thresholds (e.g., 45¬∞C for "Skin Temperature" or 95¬∞C for "Silicon Junction").</li>
          <li><strong>The Intervention:</strong> Once a threshold is hit, the Thermal Governor issues a <strong>Thermal Mitigation</strong> command.</li>
          <li><strong>Capping the OPP:</strong> It doesn't just ask nicely; it "clips" the Operating Performance Point (OPP) table. Even if the <code>schedutil</code> governor sees 100% load and wants 2.8GHz, the Thermal Framework may lock the maximum allowable frequency to 1.5GHz. This is what we call <strong>Thermal Throttling</strong>. (Depends how the OPP table is designed.)</li>
        </ol>
        
        <p>This allows modern-day chips to be aware of thermal limits beforehand instead of just waiting for overheating to happen.</p>
        
        <h2 id="energy-aware-scheduling">Energy Aware Scheduling (EAS): Intelligence over Brute Force</h2>
        
        <p>In the old days, the OS treated every CPU core the same. Today‚Äôs mobile chips use <strong>Arm‚Äôs big.LITTLE</strong> or "Prime/Big/Little" architectures. This is where <strong>Energy Aware Scheduling (EAS)</strong> comes in.</p>
        
        <h3 id="the-energy-model">The Energy Model</h3>
        
        <p>EAS uses a mathematical <strong>Energy Model (EM)</strong> of the SoC stored in the device tree. This model tells the OS exactly how many milliwatts it costs to run a specific task on a "Little" core versus a "Big" core at a certain frequency.</p>
        
        <ul>
          <li><strong>Placement Strategy:</strong> Instead of just ramping up the frequency of the current core, EAS asks: <em>"Is it more energy-efficient to run this background sync on a Little core at 1.5GHz, or a Big core at 0.8GHz?"</em></li>
          <li><strong>The Goal:</strong> It minimizes the "cost per instruction." By choosing the most efficient core-frequency combination, EAS keeps the device in a lower power state for longer, delaying the moment the Thermal Governor has to step in and ruin the fun.</li>
        </ul>
        
        <p>In today‚Äôs age of shrinking attention spans, the pressure for instant performance extends beyond humans to devices and chips as well. Modern processors operate under constant demand to deliver high performance, often resulting in increased power consumption. This is where techniques like Energy-Aware Scheduling (EAS) and Dynamic Voltage and Frequency Scaling (DVFS) become crucial. They enable fine-grained optimizations that allow chips to run at the most appropriate frequencies for a given workload, balancing performance and efficiency.</p>
        
        <p>There is much more depth to this topic‚Äîhow energy models are built, how software predicts workload behavior, applying AI-based techniques for prediction, and how frequency decisions are dynamically adjusted in real-time. I hope this brief article sparks enough curiosity to encourage further exploration into this fascinating area.</p>
        
        <div class="conclusion">
          <p><strong>Note:</strong> This article is based on my learning from the Voltage scaling section of the <em>Low Power Methodology Manual</em> and my experience working in DVFS. I would also like to thank one more <strong>EAS</strong> (Engineer who is Awesome and Stupendous), <strong>Samuel Wong</strong>, who lives and breathes this topic.</p>
        
          <p class="signature">Keep TRYing, stay WELL, and keep deBUGing.</p>
          
          <hr>
          
          <h2>Comments</h2>
          <div id="giscus-container"></div>
      </article>
    </main>
  </div>

  <div class="watermark">trywellbug.com | Ankit Singh</div>

  <script>
    // Reuse your typewriter and ToC scripts from Blog 2 here
    (function () {
      const lines = document.querySelectorAll(".typewriter-line");
      function runTypewriter(el, delayStart = 0) {
        const text = el.getAttribute("data-text") || "";
        let i = 0; el.textContent = "";
        function typing() {
          if (i <= text.length) {
            el.textContent = text.slice(0, i); i++;
            setTimeout(typing, 50 + Math.random() * 70);
          }
        }
        setTimeout(typing, delayStart);
      }
      let delay = 500;
      lines.forEach(line => {
        runTypewriter(line, delay);
        delay += (line.getAttribute("data-text") || "").length * 55;
      });
    })();

    // Simple ToC Builder
    (function () {
      const tocList = document.getElementById("toc-list");
      const headings = document.querySelectorAll("h2, h3");
      headings.forEach(h => {
        const a = document.createElement("a");
        if (!h.id) h.id = h.textContent.replace(/\s+/g, '-').toLowerCase();
        a.href = "#" + h.id;
        a.textContent = h.textContent;
        if (h.tagName === "H3") a.style.paddingLeft = "20px";
        tocList.appendChild(a);
      });
    })();
  </script>
</body>
</html>
